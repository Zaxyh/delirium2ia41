/*
quelElementEn :
Courant : envoyer 0
I : indice interessant (celui que l'on veux voir)
Element : valeur de retour : code prolog de l'élément ( 2 = diamant par
exemple)
L : Liste des éléments
*/
quelElementEn(Courant, I, Element, [T|_]) :- Courant = I, !, Element is T.
quelElementEn(Courant, I, Element, [_|R]) :- Courant2 is Courant + 1, quelElementEn(Courant2, I, Element, R).

/*
passage : renvoie vrai si un pasage est possible d'une case A à une case
B dans L qui à pour longueur de ligne Size
*/
passage(_, B, _, L) :- quelElementEn(0, B, Element, L),
	Element > 2,
	!,
	fail.


passage(A, B, Size, _) :- Ax is A // Size,
	Bx is B // Size,
	Ay is A mod Size,
	By is (B  mod Size) - 1,
	Ax = Bx,
	Ay = By,
	!.

passage(A, B, Size, _) :- Ax is A // Size,
	Bx is B // Size,
	Ay is A mod Size,
	By is (B  mod Size) + 1,
	Ax = Bx,
	Ay = By,
	!.

passage(A, B, Size, _) :- Ax is A // Size,
	Bx is (B // Size) - 1,
	Ay is A mod Size,
	By is B  mod Size,
	Ay = By,
	Ax = Bx,
	!.

passage(A, B, Size, _) :- Ax is A // Size,
	Bx is (B // Size) + 1,
	Ay is A mod Size,
	By is B  mod Size,
	Ay = By,
	Ax = Bx,
	!.



%
% Dijkstra
%   + Start        : Point de départ
%   + Finish       : Point de d'arrivée
%   - ShortestPath : Chemin le plus court
%   - Len          : Longueur de ce chemin
%


dijkstra(Start, Finish, ShortestPath, Len, L, Size) :-
  dijk( [0-[Start]], Finish, RShort, Len, L, Size),
  reverse(RShort, ShortestPath).



% Le dernier point visité est le point d'arrivée => on s'arrête
%

dijk( [ Len-[Fin|RPath] |_], Fin, [Fin|RPath], Len, L, Size) :- !.


dijk( Visited, Fin, RShortestPath, Len, L, Size) :-
  % Recherche du meilleur candidat (prochain point à ajouter au graphe)
  %   et appel récursif au prédicat
  %

  bestCandidate(Visited, BestCandidate, L, Size),
  dijk( [BestCandidate|Visited], Fin, RShortestPath, Len, L, Size).



%
% Recherche toutes les arrêtes pour lesquelles on a:
%  - un point dans le graphe (visité)
%  - un point hors du graphe (candidat)
%
% Retourne le point qui minimise la distance par rapport à l'origine
%


bestCandidate(Paths, BestCandidate, L, Size) :-

  % à partir d'un point P1 :

  findall(
     NP            % on fait la liste de tous les points P2 tels que:
  ,
    (
      member( Len-[P1|Path], Paths),  % - le point P2 a déjà été visité
      %arc(P1,P2, Dist),                % - il existe un arc allant de P1 à P2, de distance Dist
	write(P1), write(P2),
     passage(P1, P2, Size, L),
     \+isVisited(Paths, P2),         % - le point P2 n'a pas encore été visité

      NLen is Len+1,               % on calcule la distance entre l'origine et le point P2

      NP=NLen-[P2,P1|Path]            % on met chaque élément de la liste sous la forme: Distance-Chemin
                                      % pour pouvoir les trier avec le prédicat keysort/2
    )
  ,
    Candidates
  ),

  % On trie et on retient le chemin le plus court
  minimum(Candidates, BestCandidate).



%
% Sort le meilleur candidat parmi une liste de candidats
% (= celui de chemin le moins long)
%

minimum(Candidates, BestCandidate) :-
  keysort(Candidates, [BestCandidate|_]).



%
% Teste si un point P a déjà été visité
%

isVisited(Paths, P) :-
  memberchk(_-[P|_], Paths).

